{"version":3,"file":"MSEPlayer.umd.min.js","sources":["../src/MSEPlayer.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface MSESdkError<T = any> {\n  type: string;\n  error?: T;\n}\n\ninterface Transformer {\n  (buffers: Array<ArrayBuffer>): Array<ArrayBuffer> | Promise<Array<ArrayBuffer>>;\n}\n\ninterface MSESdkOption {\n  // for users, `files` is more meaningful, so I don't use `blobs`\n  files?: Array<Blob>;\n  mimeType?: string;\n  onError?: Function;\n  ignoreError?: boolean;\n  transformer?: Transformer;\n}\n\n/**\n * @example\n * const player = new MSEPlayer()\n * player.appendFiles(files)\n * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Media_Source_Extensions_API\n */\nexport default class MSEPlayer {\n  envSupported: boolean\n  onError: Function\n  mimeType!: string\n  sourceBuffer!: SourceBuffer | null\n  ignoreError!: boolean\n  transformer!: Transformer\n  mediaSource!: MediaSource | null\n  lastAppend$!: Promise<void>\n  constructor (option: MSESdkOption = { }) {\n    const { files = [], mimeType = 'audio/mpeg', onError, ignoreError = true, transformer = identity } = option\n    this.envSupported = MSEPlayer.checkEnvSupported()\n  \n    this.onError = (...args: any[]) => {\n      if (isFunction(onError)) {\n        onError.call(this, ...args)\n      }\n    }\n\n    if (!this.envSupported) {\n      this.onError(genError('MEDIA_SOURCE_NOT_SUPPORTED'))\n      return\n    }\n\n    if (!MediaSource.isTypeSupported(mimeType)) {\n      this.onError(genError('MIME_TYPE_NOT_SUPPORTED'))\n      return\n    }\n\n    this.mimeType = mimeType\n    this.sourceBuffer = null\n    this.ignoreError = ignoreError\n    this.transformer = transformer\n    this.mediaSource = new MediaSource()\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const player = this\n    function onSourceOpenWithPromise (): Promise<void> {\n      return new Promise((resolve) => {\n        const mediaSource: MediaSource = player.mediaSource as MediaSource\n        mediaSource.addEventListener('sourceopen', onSourceOpen)\n        function onSourceOpen () {\n          mediaSource.removeEventListener('sourceopen', onSourceOpen)\n          player.sourceBuffer = mediaSource.addSourceBuffer(player.mimeType)\n          resolve()\n        }\n      })\n    }\n\n    this.lastAppend$ = onSourceOpenWithPromise()\n\n    if (files.length > 0) {\n      this.appendFiles(files)\n    }\n  }\n\n  static checkEnvSupported () {\n    return 'MediaSource' in window\n  }\n\n  /**\n   * appendFiles\n   */\n  appendFiles (files: Array<Blob> = [], transformer: Transformer = identity, ignorePrevError = true) {\n    files = toArray(files)\n\n    if (ignorePrevError) {\n      this.lastAppend$.catch(() => { })\n    }\n\n    const combinedTransformer = (buffers: Array<ArrayBuffer>) => {\n      return Promise.resolve(buffers)\n        .then(transformer) // specific transformer\n        .then((buffers) => this.transformer(buffers)) // common transformer\n    }\n\n    const currentAppend$ = this.lastAppend$.then(\n      () => combine(files, this.mediaSource as MediaSource, this.sourceBuffer as SourceBuffer, combinedTransformer)\n    )\n\n    this.lastAppend$ = currentAppend$.catch((err) => {\n      this.onError(genError('APPEND_ERROR', err))\n    })\n\n    return this.ignoreError ? this.lastAppend$ : currentAppend$\n  }\n\n  destroy () {\n    this.mediaSource = null\n    this.sourceBuffer = null\n  }\n}\n\n/**\n * readBuffer - read blobs and get arrayBuffers\n */\nfunction read (blobs: Array<Blob>): Promise<Array<ArrayBuffer>> {\n  return Promise.all(blobs.map(function(blob) {\n    return new Promise<ArrayBuffer>(function(resolve, reject) {\n      // hmmm, no need to unbind, if it's smart enough\n      const reader = new FileReader()\n      reader.addEventListener('load', () => {\n        // the result must be `ArrayBuffer`\n        resolve(reader.result as ArrayBuffer)\n      })\n      reader.readAsArrayBuffer(blob)\n      reader.addEventListener('error', (err) => {\n        reject(genError('READ_FILE_ERROR', err))\n      })\n    })\n  }))\n}\n\n/**\n * buffer - append buffers to specific sourceBuffer\n */\nfunction buffer (mediaSource: MediaSource, sourceBuffer: SourceBuffer, buffers: Array<ArrayBuffer>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    sourceBuffer.addEventListener('updateend', onUpdateEnd)\n    sourceBuffer.addEventListener('error', onAppendError)\n\n    // it's async when `appendBuffer`,\n    // we should use `updateend` event(triggers when `append` or `removed`) to ensure the orders\n    function onUpdateEnd () {\n      if (buffers.length === 0) {\n        mediaSource.endOfStream()\n        // don't forget to remove\n        sourceBuffer.removeEventListener('updateend', onUpdateEnd)\n        sourceBuffer.removeEventListener('error', onAppendError)\n        resolve()\n        return\n      }\n      sourceBuffer.appendBuffer(buffers.shift() as ArrayBuffer)\n    }\n\n    function onAppendError (err: any) {\n      // no need to unbind `updateend` and invoke `endOfStream` here,\n      // because when `error` occurs, `updateend` will go according to the spec.\n      // @see https://w3c.github.io/media-source/#sourcebuffer-append-error\n      reject(genError('APPEND_BUFFER_ERROR', err))\n    }\n\n    // trigger first buffer\n    onUpdateEnd()\n  })\n}\n\n/**\n * combine - combine the `read` process and the `buffer` process\n * to ensure the `read` process is excuted before the `buffer` process.\n * just a combination.\n */\nfunction combine (files: Array<Blob>, mediaSource: MediaSource, sourceBuffer: SourceBuffer, transformer: Transformer) {\n  return read(files).then((buffers) => transformer(buffers)).then((buffers) => buffer(mediaSource, sourceBuffer, buffers))\n}\n\n/**\n * identity\n */\nfunction identity<T> (x: T) {\n  return x\n}\n\n/**\n * isFunction\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isFunction (x: any): x is Function {\n  return Object.prototype.toString.call(x) === '[object Function]'\n}\n\n/**\n * toArray\n */\nfunction toArray<T> (xs: ArrayLike<T>): Array<T> {\n  return [].slice.call(xs)\n}\n\n/**\n * genError\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction genError<T = any> (type: string, error?: T): MSESdkError<T> {\n  return {\n    type,\n    error\n  }\n}\n"],"names":["option","_a","files","_b","mimeType","onError","_c","ignoreError","_d","transformer","this","envSupported","MSEPlayer","checkEnvSupported","_i","args","x","Object","prototype","toString","call","isFunction","_this","MediaSource","isTypeSupported","sourceBuffer","mediaSource","player","lastAppend$","Promise","resolve","addEventListener","onSourceOpen","removeEventListener","addSourceBuffer","length","appendFiles","genError","identity","type","error","window","ignorePrevError","combinedTransformer","buffers","then","xs","slice","toArray","catch","currentAppend$","blobs","all","map","blob","reject","reader","FileReader","result","readAsArrayBuffer","err","read","onUpdateEnd","endOfStream","onAppendError","appendBuffer","shift","buffer","combine"],"mappings":"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"}