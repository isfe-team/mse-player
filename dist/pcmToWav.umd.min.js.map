{"version":3,"file":"pcmToWav.umd.min.js","sources":["../src/pcmToWav.ts"],"sourcesContent":["\n/**\n * pcmToWav\n * @example\n * pcmToWav(file).then((src) => $audio.src = src)\n */\nexport default function pcmToWav (file: Blob, sampleRate = 16000, sampleBits = 16, channelCount = 1) {\n  const reader = new FileReader()\n\n  // no need to `removeEventListener` if smart enough\n  const promise = new Promise((resolve, reject) => {\n    reader.addEventListener('load', () => {\n      const buffer = addWavHeader(reader.result as ArrayBuffer, sampleRate, sampleBits, channelCount)\n      resolve(bufferToBase64(buffer))\n    })\n\n    reader.addEventListener('error', (err) => {\n      reject(err)\n    })\n  })\n\n  reader.readAsArrayBuffer(file)\n\n  return promise\n}\n\n/**\n * addWavHeader\n */\nfunction addWavHeader (samples: ArrayBuffer, sampleRate: number, sampleBits: number, channelCount: number) {\n  const dataLength = samples.byteLength\n  const buffer = new ArrayBuffer(44 + dataLength)\n  const view = new DataView(buffer)\n  function writeString (view: DataView, offset: number, str: string) {\n    for (let i = 0; i < str.length; i++) {\n      view.setUint8(offset + i, str.charCodeAt(i))\n    }\n  }\n  let offset = 0\n  /* 资源交换文件标识符 */\n  writeString(view, offset, 'RIFF'); offset += 4\n  /* 下个地址开始到文件尾总字节数,即文件大小-8 */\n  view.setUint32(offset, /*32*/ 36 + dataLength, true); offset += 4\n  /* WAV文件标志 */\n  writeString(view, offset, 'WAVE'); offset += 4\n  /* 波形格式标志 */\n  writeString(view, offset, 'fmt '); offset += 4\n  /* 过滤字节,一般为 0x10 = 16 */\n  view.setUint32(offset, 16, true); offset += 4\n  /* 格式类别 (PCM形式采样数据) */\n  view.setUint16(offset, 1, true); offset += 2\n  /* 通道数 */\n  view.setUint16(offset, channelCount, true); offset += 2\n  /* 采样率,每秒样本数,表示每个通道的播放速度 */\n  view.setUint32(offset, sampleRate, true); offset += 4\n  /* 波形数据传输率 (每秒平均字节数) 通道数×每秒数据位数×每样本数据位/8 */\n  view.setUint32(offset, sampleRate * channelCount * (sampleBits / 8), true); offset +=4\n  /* 快数据调整数 采样一次占用字节数 通道数×每样本的数据位数/8 */\n  view.setUint16(offset, channelCount * (sampleBits / 8), true); offset += 2\n  /* 每样本数据位数 */\n  view.setUint16(offset, sampleBits, true); offset += 2\n  /* 数据标识符 */\n  writeString(view, offset, 'data'); offset += 4\n  /* 采样数据总数,即数据总大小-44 */\n  view.setUint32(offset, dataLength, true); offset += 4\n  function floatTo32BitPCM (output: DataView, offset: number, input: ArrayBuffer) {\n    const i32xs = new Int32Array(input)\n    for (let i = 0; i < i32xs.length; i++, offset += 4) {\n      output.setInt32(offset, i32xs[i], true)\n    }\n  }\n  function floatTo16BitPCM (output: DataView, offset: number, input: ArrayBuffer){\n    const i16xs = new Int16Array(input)\n    for (let i = 0; i < i16xs.length; i++, offset+=2) {\n      output.setInt16(offset, i16xs[i], true)\n    }\n  }\n  function floatTo8BitPCM (output: DataView, offset: number, input: ArrayBuffer) {\n    const i8xs = new Int8Array(input)\n    for (let i = 0; i < i8xs.length; i++, offset++){\n      output.setInt8(offset, i8xs[i])\n    }\n  }\n  if (sampleBits === 16) {\n    floatTo16BitPCM(view, 44, samples)\n  } else if (sampleBits === 8) {\n    floatTo8BitPCM(view, 44, samples)\n  } else {\n    floatTo32BitPCM(view, 44, samples)\n  }\n  return view.buffer\n}\n\n/**\n * bufferToBase64\n */\nfunction bufferToBase64 (buffer: ArrayBuffer) {\n  const content = new Uint8Array(buffer).reduce((data, byte) => {\n    return data + String.fromCharCode(byte)\n  }, '')\n\n  return `data:audio/wav;base64,${btoa(content)}`\n}\n"],"names":["file","sampleRate","sampleBits","channelCount","reader","FileReader","promise","Promise","resolve","reject","addEventListener","buffer","samples","dataLength","byteLength","ArrayBuffer","view","DataView","writeString","offset","str","i","length","setUint8","charCodeAt","setUint32","setUint16","output","input","i16xs","Int16Array","setInt16","floatTo16BitPCM","i8xs","Int8Array","setInt8","floatTo8BitPCM","i32xs","Int32Array","setInt32","floatTo32BitPCM","addWavHeader","result","content","Uint8Array","reduce","data","byte","String","fromCharCode","btoa","bufferToBase64","err","readAsArrayBuffer"],"mappings":"8MAMkCA,EAAYC,EAAoBC,EAAiBC,gBAArCF,qBAAoBC,mBAAiBC,KACjF,IAAMC,EAAS,IAAIC,WAGbC,EAAU,IAAIC,QAAQ,SAACC,EAASC,GACpCL,EAAOM,iBAAiB,OAAQ,WAC9B,IAAMC,EAiBZ,SAAuBC,EAAsBX,EAAoBC,EAAoBC,GACnF,IAAMU,EAAaD,EAAQE,WACrBH,EAAS,IAAII,YAAY,GAAKF,GAC9BG,EAAO,IAAIC,SAASN,GAC1B,SAASO,EAAaF,EAAgBG,EAAgBC,GACpD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAIE,OAAQD,IAC9BL,EAAKO,SAASJ,EAASE,EAAGD,EAAII,WAAWH,IAG7C,IAAIF,EAAS,EAEbD,EAAYF,EAAMG,EAAQ,QAASA,GAAU,EAE7CH,EAAKS,UAAUN,EAAe,GAAKN,GAAY,GAE/CK,EAAYF,EAF0CG,GAAU,EAEtC,QAE1BD,EAAYF,EAFuBG,GAAU,EAEnB,QAASA,GAAU,EAE7CH,EAAKS,UAAUN,EAAQ,IAAI,GAAOA,GAAU,EAE5CH,EAAKU,UAAUP,EAAQ,GAAG,GAAOA,GAAU,EAE3CH,EAAKU,UAAUP,EAAQhB,GAAc,GAAOgB,GAAU,EAEtDH,EAAKS,UAAUN,EAAQlB,GAAY,GAAOkB,GAAU,EAEpDH,EAAKS,UAAUN,EAAQlB,EAAaE,GAAgBD,EAAa,IAAI,GAAOiB,GAAS,EAErFH,EAAKU,UAAUP,EAAQhB,GAAgBD,EAAa,IAAI,GAAOiB,GAAU,EAEzEH,EAAKU,UAAUP,EAAQjB,GAAY,GAEnCgB,EAAYF,EAF8BG,GAAU,EAE1B,QAASA,GAAU,EAE7CH,EAAKS,UAAUN,EAAQN,GAAY,GAAOM,GAAU,EAmBjC,KAAfjB,EAZJ,SAA0ByB,EAAkBR,EAAgBS,GAE1D,IADA,IAAMC,EAAQ,IAAIC,WAAWF,GACpBP,EAAI,EAAGA,EAAIQ,EAAMP,OAAQD,IAAKF,GAAQ,EAC7CQ,EAAOI,SAASZ,EAAQU,EAAMR,IAAI,GAUpCW,CAAgBhB,EAAM,GAAIJ,GACF,IAAfV,EARX,SAAyByB,EAAkBR,EAAgBS,GAEzD,IADA,IAAMK,EAAO,IAAIC,UAAUN,GAClBP,EAAI,EAAGA,EAAIY,EAAKX,OAAQD,IAAKF,IACpCQ,EAAOQ,QAAQhB,EAAQc,EAAKZ,IAM9Be,CAAepB,EAAM,GAAIJ,GArB3B,SAA0Be,EAAkBR,EAAgBS,GAE1D,IADA,IAAMS,EAAQ,IAAIC,WAAWV,GACpBP,EAAI,EAAGA,EAAIgB,EAAMf,OAAQD,IAAKF,GAAU,EAC/CQ,EAAOY,SAASpB,EAAQkB,EAAMhB,IAAI,GAoBpCmB,CAAgBxB,EAAM,GAAIJ,GAE5B,OAAOI,EAAKL,OA9EO8B,CAAarC,EAAOsC,OAAuBzC,EAAYC,EAAYC,GAClFK,EAmFN,SAAyBG,GACvB,IAAMgC,EAAU,IAAIC,WAAWjC,GAAQkC,OAAO,SAACC,EAAMC,GACnD,OAAOD,EAAOE,OAAOC,aAAaF,IACjC,IAEH,MAAO,yBAAyBG,KAAKP,GAxFzBQ,CAAexC,MAGzBP,EAAOM,iBAAiB,QAAS,SAAC0C,GAChC3C,EAAO2C,OAMX,OAFAhD,EAAOiD,kBAAkBrD,GAElBM"}